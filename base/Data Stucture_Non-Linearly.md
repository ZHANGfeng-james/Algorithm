> 数据结构和算法有什么关系呢？**为什么大部分书都把这两个东西放到一块儿来讲呢**？这是因为，**数据结构和算法是相辅相成的**。**数据结构是为算法服务的，算法要作用在特定的数据结构之上**。因此，我们无法孤立数据结构来讲算法，也无法孤立算法来讲数据结构。比如，因为数组具有**随机访问**的特点，常用的二分查找算法需要用数组来存储数据。但如果我们选择**链表**这种数据结构，二分查找算法就无法工作了，因为链表并不支持随机访问。
>

**什么是数据结构？**数据结构就是一组数据的存储结构。而算法则是操作数据的一组方法。数据结构是**静态的**，它只是**组织数据的一种方式**。如果不在它的基础上操作、构建算法，孤立存在的数据结构就是没用的。**我们在总结线性表时，要特别注意数据结构的特点、使用场景和（与其他数据结构的使用）区别。**

线性表和非线性表的概念：

* 线性表就是**数据排成像一条线一样的结构**。**每个线性表上的数据最多只有前和后两个方向**。**其实除了数组，链表、队列、栈等也是线性表结构**。
* 非线性表，比如**二叉树、堆、图**等。之所以叫非线性，是因为，**在非线性表中，数据之间并不是简单的前后关系**。

<img src="./img/Snipaste_2018-11-03_09-41-33.png" style="zoom: 80%;" />

# 1 树

“树”这种数据结构真的很像我们现实生活中的“树”，这里面**<u>每个元素我们叫做“节点”</u>**；用来连接相邻节点之间的**<u>关系</u>**，我们叫做“父子关系”。

树结构多种多样，不过我们最常用还是二叉树。二叉树：**<u>每个节点最多有两个“叉”</u>**，也就是两个子节点（这也就是二叉的含义），分别是**<u>左子节点</u>**和**<u>右子节点</u>**。不过，二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点。

特殊的二叉树：

* 叶子节点全都在**<u>最底层</u>**，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫做**<u>满二叉树</u>**。
* 叶子节点都在**<u>最底下两层</u>**，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫做**<u>完全二叉树</u>**。

> 之所以需要特别注意完全二叉树，是为了引出**二叉树的存储结构**！

想要存储一棵二叉树，我们有两种方法，**<u>一种是基于指针或者引用的二叉链式存储法</u>**，**<u>一种是基于数组的顺序存储法</u>**。

比较简单、直观的**链式存储法**：每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。我们只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。**大部分二叉树代码都是通过这种结构来实现的**。

基于数组的**顺序存储法**：如果节点 X **<u>存储在数组中下标为 i 的位置</u>**，下标为 2 * i 的位置存储的就是**<u>左子节点</u>**，下标为 2 * i + 1 的位置存储的就是**<u>右子节点</u>**。反过来，下标为 i/2 的位置存储就是它的父节点。通过这种方式，我们只要知道根节点存储的位置（一般情况下，为了方便计算子节点，根节点会存储在下标为 1 的位置），这样就可以通过下标计算，把整棵树都串起来。

所以，**<u>如果某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式</u>**。因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。这也是为什么完全二叉树会单独拎出来的原因，也是为什么完全二叉树要求最后一层的子节点都靠左的原因。

**重点掌握**的是：这种数据结构——二叉树——**遍历**的**执行过程**。

**<u>如何将所有节点都遍历打印出来呢？</u>**经典的方法有三种，前序遍历、中序遍历和后序遍历。其中，前、中、后序，表示的是节点与它的左右子树节点遍历打印的先后顺序：

* **<u>前序遍历</u>**是指，对于树中的任意节点（包含**递归**的概念）来说，**先打印这个节点**，然后再打印它的左子树，最后打印它的右子树。
* **<u>中序遍历</u>**是指，对于树中的任意节点（包含递归的概念）来说，先打印它的左子树，**然后再打印它本身**，最后打印它的右子树。
* **<u>后序遍历</u>**是指，对于树中的任意节点（包含**递归**的概念）来说，先打印它的左子树，然后再打印它的右子树，**最后打印这个节点本身**。

前序、中序、后序遍历，依次指的就是**当前遍历节点**相对于其左右子树的遍历顺序。实际上，**<u>二叉树的前、中、后序遍历就是一个递归的过程</u>**，因此在实现二叉树的遍历时，是需要使用递归技巧的。

## 1.1 二叉查找树

接下来进入一个特殊的数据结构：**二叉查找树**。二叉查找树要求，**<u>在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值</u>**。 二叉查找树是**<u>为了实现快速查找而生的</u>**。不过，它不仅仅**<u>支持快速查找一个数据，还支持快速插入、删除一个数据</u>**。

二叉查找树的功能特征，是紧密依赖其特殊的结构！

**重点掌握**的是：这种数据结构——二叉树查找树——重点操作**查找、插入、删除**的**执行过程**。

* 查找：我们先取根节点，如果它等于我们要查找的数据，那就返回。如果要查找的数据比根节点的值小，那就在左子树中**<u>递归</u>**查找；如果要查找的数据比根节点的值大，那就在右子树中**<u>递归</u>**查找。
* 快速查找最大节点和最小节点、前驱节点和后继节点
* 插入：新插入的数据一般都是在叶子节点上，所以我们只需要从根节点开始，依次比较要插入的数据和节点的大小关系。如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再**递归遍历**右子树，查找插入位置。同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再**递归遍历**左子树，查找插入位置。
* 删除：**<u>针对要删除节点的子节点个数的不同</u>**，我们需要分**<u>三种情况</u>**来处理
  * 第一种情况是，如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为 null。
  * 第二种情况是，如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。
  * 第三种情况是，如果要删除的节点有两个子节点，这就比较复杂了。我们需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了），所以，我们可以应用上面两条规则来删除这个最小节点。
* 中序遍历二叉查找树：输出**有序的**数据序列。

关于二叉查找树的扩展：支持重复数据的二叉查找树。**重点掌握**的是：这种数据结构——支持重复数据的二叉树查找树——重点操作**查找、插入、删除**的**执行过程**。

* 插入：在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理。
* 查找：当要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。
* 删除：对于删除操作，我们也需要先查找到每个要删除的节点，然后再按前面讲的删除操作的方法，依次删除。

二叉查找树和 HashMap 的比较：

1. 散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序列。
2. 散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。
3. 笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。
4. 散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。
5. 为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。

综合这几点，**平衡二叉查找树**在某些方面还是优于散列表的，所以，这两者的存在并不冲突。我们在实际的开发过程中，需要结合具体的需求来选择使用哪一个。

## 1.2 红黑树

二叉查找树是最常用的一种二叉树，它支持快速插入、删除、查找操作，各个操作的时间复杂度跟树的高度成正比，理想情况下，时间复杂度是 O(logn)。不过，二叉查找树在**<u>频繁的动态更新过程</u>**中，可能会出现树的高度远大于 
$$
\log_2n
$$
 的情况，从而导致**<u>各个操作的效率下降</u>**。极端情况下，二叉树会退化为链表，时间复杂度会退化到 O(n)。要解决这个复杂度退化的问题，我们需要设计一种**<u>平衡二叉查找树</u>**，在工程中，很多用到平衡二叉查找树的地方都会用红黑树。

**<u>平衡二叉树</u>**的严格定义是这样的：**<u>二叉树中任意一个节点的左右子树的高度相差不能大于 1</u>**。

## 1.3 递归树

**递归的思想**就是，将大问题分解为小问题来求解，然后再将小问题分解为小小问题。这样一层一层地分解，直到问题的数据规模被分解得足够小，不用继续递归分解为止。如果我们把这个一层一层的分解过程画成图，它其实就是一棵树。我们给这棵树起一个名字，叫作**递归树**。

比如下面这个递归问题：1 个细胞的生命周期是 3 小时，1 小时分裂一次。求 n 小时后，容器内有多少细胞？

> 最开始容器中只有 1 个细胞，在经过 1 小时后做了一次分裂动作。此时容器中有 2 个细胞，其中 1 个细胞的生存期是 1 小时，另一个细胞是新细胞（生存期是 0 小时）。

从细胞分裂的结果来看，Cell(0) 表示生存期是 0 的细胞：

1. 初始状态，容器内是 Cell(0) = 1 个细胞，因此 T(0) = 1
2. 经过 1 小时后，容器内存活的细胞是这样的：Cell(0) + Cell(1) = 2 个细胞，因此 T(1) = 2
3. 经过 2 小时后，容器内存活的细胞是这样的：2 * Cell(0) + Cell(1) + Cell(2) = 4 个细胞，因此 T(2) = 4
4. 经过 3 小时后，容器内存活的细胞是这样的：4 * Cell(0) + 2 * Cell(1) + Cell(2) = 7 个细胞，因此 T(3) = 7
5. 经过 4 小时后，容器内存活的细胞是这样的：7 * Cell(0) + 4 * Cell(1) + 2Cell(2) = 13 个细胞，因此 T(4) = 13
6. 经过 5 小时候，容器内存活的细胞是这样的：13 * Cell(0) + 7 * Cell(1) + 4Cell(2) = 24 个细胞，因此 T(5) = 24
7. ......

按照题意，**容器内存活的细胞数目**和**时间**的关系是这样的：

$$
\begin{cases} 
T(n) = T(n-1) + T(n-2) + T(n-3),  & n>=3 \\
T(2) = 4, & \text n = 2 \\
T(1) = 2, & \text n = 1 \\
T(0) = 1, & \text n = 0 \\
\end{cases}
$$
用**递归代码**实现：

~~~go
func cellSum(time int) int {
	if time == 0 {
		return 1
	}
	if time == 1 {
		return 2
	}
	if time == 2 {
		return 4
	}

	return cellSum(time-1) + cellSum(time-2) + cellSum(time-3)
}
~~~

实际上，上面总结出来的公式就是**递推公式**。

也就是说，如果要求解经过 N 个小时后，容器中的细胞存活数量，对应的值就是 T(N)。而该值可以分解成 3 个值求解：T(N-1)、T(N-2) 和 T(N-3)，紧接着，对应的这 3 个值中的每个值都可分解成另外 3 个值进行求解。

## 1.4 Trie 树

Trie 树，也叫“字典树”（又叫做：**前缀树**）。顾名思义，它是**一个树形结构**。它是一种专门处理**字符串匹配**的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题。当然，这样一个问题可以有多种解决方法，比如散列表、红黑树以及一些字符串匹配算法，但是，Trie 树在这个问题的解决上，有它**特有的优点**。不仅如此，Trie 树能解决的问题也不限于此。

**Trie 树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起**。其中，**根节点不包含任何信息**。每个节点表示一个字符串中的字符，从根节点到**红色节点**的一条路径表示一个字符串（注意：红色节点并不都是叶子节点）。

Trie 树**构造过程的每一步，都相当于往 Trie 树中插入一个字符串**。当所有字符串都插入完成之后，Trie 树就构造好了。

当我们在 Trie 树中查找一个字符串的时候，比如查找字符串“her”，那我们将要查找的字符串**分割**成单个的字符 h，e，r，然后**从 Trie 树的根节点开始匹配**。如果我们要查找的是字符串“he”呢？我们还用上面同样的方法，从根节点开始，沿着某条路径来匹配。但是如果，**路径的最后一个节点“e”并不是红色的**。也就是说，“he”是某个字符串的**前缀子串**，但并**不能完全匹配任何字符串**。

从我们实际的使用来看，Trie 树是一个**多叉树**。

## 1.5 B+ 树









# 2 堆

堆，其实就是一种完全二叉树！

堆排序







# 3 图





